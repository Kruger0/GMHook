/*
    []=============================================[]
    ||  Webhook Integration System for GameMaker   ||
    ||  https://github.com/Kruger0/GMHook          ||
    ||                                             ||
    ||                                 --KrugDev   ||
    []=============================================[]
*/

///@desc Instantiates a Webhook object that can be configured and executed.
///@arg {String} url The webhook url as a string
///@return {DiscordWebhook} A new webhook instance.
function DiscordWebhook(url) constructor {
    
    #region Private
    self.url    = url;
    payload     = {};
    files       = [];
    message_id  = undefined;
    request_id  = undefined;
    processed   = false;
    boundary    = sha1_string_utf8(date_datetime_string(date_current_datetime()));
    
    ///@desc Internal trace function for debug messages.
    ///@arg {String} _msg The message to trace.
    ///@ignore
    static __Trace = function(_msg) {
        show_debug_message($"[GMHook] - {_msg}");
    }
    
    ///@desc Creates the multipart form data body for the HTTP request.
    ///@return {Buffer} The buffer containing the request body.
    ///@ignore
    static __CreateBody = function() {
        var _buffer = buffer_create(1024, buffer_grow, 1);
        var _body = ""+
        $"--{boundary}\r\n"+
        "Content-Disposition: form-data; name=\"payload_json\"\r\n\r\n"+
        json_stringify(payload) + "\r\n";
        buffer_write(_buffer, buffer_text, _body);
        // Process files
        for (var i = 0; i < array_length(files); i++) {
            var _file = files[i].file;
            var _data = files[i].data;
            var _content = $"--{boundary}\r\n"+
            $"Content-Disposition: form-data; name=\"file_{i}\"; filename=\"{_file}\"\r\n\r\n";
            buffer_write(_buffer, buffer_text, _content);
            buffer_copy(_data, 0, buffer_get_size(_data), _buffer, buffer_tell(_buffer));
            buffer_seek(_buffer, buffer_seek_relative, buffer_get_size(_data));
            buffer_write(_buffer, buffer_text, "\r\n");
            buffer_delete(_data);
        }
        // Finish message
        buffer_write(_buffer, buffer_text, $"--{boundary}--");
        return _buffer;
    }
    
    ///@desc Creates the HTTP headers for the Discord API request
    ///@arg {Buffer} body The body buffer to get the content length.
    ///@return {DsMap} The header map for the request.
    ///@ignore
    static __CreateHeader = function() {
        var _header = ds_map_create();
        _header[? "Host"] = "discord.com";
        _header[? "Content-Type"] = $"multipart/form-data; boundary={boundary}";
        return _header;
    }
    #endregion
    
    ///@desc Sets or changes the webhook URL.
    ///@arg {String} url The new webhook URL as a string.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetURL = function(url) {
        self.url = url;
        return self;
    }

    ///@desc Sets a user and avatar that overrides the default ones defined in the discord server config.
    ///@arg {String} username The webhook name.
    ///@arg {String} avatar_url The webhook avatar.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetUser = function(username, avatar_url) {
        if (username != undefined && username!= "") {
            payload.username = username;
        }
        if (avatar_url != undefined && avatar_url!= "") {
            payload.avatar_url = avatar_url;
        }
        return self;
    }
    
    ///@desc Sets the content/text message for the webhook.
    ///@arg {String} content The message content to send.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetContent = function(content) {
        payload.content = content;
        return self;
    }
    
    ///@desc Sets the name of the thread to be created (primarily for Forum Channels).
    ///@arg {String} thread_name The name of the new thread.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetThread = function(thread_name) {
        payload.thread_name = thread_name;
        return self;
    }
    
    ///@desc Sets message flags to suppress embeds or notifications (silent message).
    ///@arg {Bool} suppress_embeds Whether to hide embeds generated by links.
    ///@arg {Bool} suppress_notifications Whether to send silently whthout any mention or role notification.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetFlags = function(suppress_embeds = false, suppress_notifications = false) {
        var _flags = 0;
        if (suppress_embeds) {
            _flags = _flags | 4; 
        }
        if (suppress_notifications) {
            _flags = _flags | 4096;
        }
        payload.flags = _flags;
        return self;
    }
    
    ///@desc Sets the entire payload for the webhook.
    ///@arg {Struct|String} payload The payload struct or JSON string to use.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetPayload = function(payload) {
        if (is_struct(payload)) {
            self.payload = variable_clone(payload);
        } else if (is_string(payload)) {
            try {
                self.payload = json_parse(payload);
            } catch (e) {
                __Trace($"Invalid payload string: {payload}");
            };
        } else {
            __Trace($"Invalid payload: {payload}");
        }        
        return self;
    }
    
    ///@desc Get the entire payload for the webhook as a struct.
    ///@return {Struct} Returns the payload struct.
    static GetPayload = function() {
        return payload;
    }
    
    ///@desc Sets the entire embed array for the webhook.
    ///@arg {Array} embeds Array of embeds to use
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetEmbeds = function(embeds) {
        payload[$ "embeds"] = variable_clone(embeds);
        return self;
    }
    
    ///@desc Sets whether the message should be sent with text-to-speech.
    ///@arg {Bool} enabled Whether TTS should be enabled.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static SetTTS = function(enabled) {
        payload.tts = enabled;
        return self;
    }
    
    ///@desc Adds an embed to the webhook message.
    ///@arg {Struct.DiscordEmbed} embed The embed object to add.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static AddEmbed = function(embed) {
        payload[$ "embeds"] ??= [];
        array_push(payload.embeds, variable_clone(embed));
        return self;
    }
    
    ///@desc Adds a poll to the webhook message.
    ///@arg {Struct.DiscordPoll} poll The poll object to add.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static AddPoll = function(poll) {
        payload.poll = variable_clone(poll);
        return self;
    }
    
    ///@desc Adds a file attachment from disk to the webhook.
    ///@arg {String} filename The path to the file to attach.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static AddFile = function(filename) {
        if (!file_exists(filename)) {
            __Trace($"File {filename} not found!");
            return self;
        }
        array_push(files, {
            file : filename,
            data : buffer_load(filename),
        })
        return self;
    }
    
    ///@desc Adds a buffer as a file attachment to the webhook.
    ///@arg {Buffer} buffer The buffer to attach.
    ///@arg {String} name The filename for the attachment.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static AddBuffer = function(buffer, name) {
        if (!buffer_exists(buffer)) {
            __Trace($"Buffer {buffer} not found!");
            return self;
        }
        var _size = buffer_get_size(buffer);
        var _buffer = buffer_create(_size, buffer_fixed, buffer_get_alignment(buffer));
        buffer_copy(buffer, 0, _size, _buffer, 0);
        array_push(files, {
            file    : name,
            data    : _buffer,
        })
        return self;
    }
    
    ///@desc Executes the webhook and sends the message to Discord.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static Execute = function() {
        processed = false;
        var _url    = url+"?wait=true";
        var _method = "POST";
        var _header = __CreateHeader();
        var _body   = __CreateBody();
        request_id = http_request(_url, _method, _header, _body);
        buffer_delete(_body);
        ds_map_destroy(_header);
        return self;
    }
    
    ///@desc Edits a previously sent message (requires message_id from Execute).
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static Edit = function() {
        processed = false;
        if (message_id == undefined) {
            __Trace("Failed to edit: Message ID is undefined");
            return self;
        }
        var _url    = $"{url}/messages/{message_id}"+"?wait=true";
        var _method = "PATCH";
        var _header = __CreateHeader();
        var _body   = __CreateBody();
        request_id = http_request(_url, _method, _header, _body);
        buffer_delete(_body);
        ds_map_destroy(_header);
        return self;
    }
    
    ///@desc Deletes a previously sent message (requires message_id from Execute).
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static Delete = function() {
        processed = false;
        if (message_id == undefined) {
            __Trace("Failed to delete: Message ID is undefined");
            return self;
        }
        var _url    = $"{url}/messages/{message_id}"+"?wait=true";
        var _method = "DELETE";
        var _header = __CreateHeader();
        var _body   = 0;
        request_id = http_request(_url, _method, _header, _body);
        ds_map_destroy(_header);
        return self;
    }
    
    ///@desc Processes the async HTTP response from Discord API.
    ///@arg {Bool} [trace] Whether to output trace messages for status codes. Defaults to false
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static Async = function(trace = false) {
        var _async = json_parse(json_encode(async_load));
        if (_async[$ "id"] != request_id) return self;
        var _http_status = _async[$ "http_status"];
        if (_http_status == undefined) return self;
        var _result = _async[$ "result"] ?? "{}";
        if (_result != "") {
            _result = json_parse(_result);
        } else {
          _result = {};
        }
        if (trace) {
            switch (_http_status) {
                case 200: __Trace("200 | Message Sent") break;
                case 204: __Trace("204 | Message Deleted") break;
                case 404: __Trace("404 | Message Not Found") break;
                case 429: __Trace("429 | Too Many Requests") break;
                default:  __Trace($"{_http_status} | {_result}")
            }
        }        
        message_id = _result[$ "id"];
        processed = true;
        return self;
    }
    
    ///@desc Checks if the last request has been processed.
    ///@return {Bool} True if the request was processed, false otherwise.
    static Processed = function() {
        return processed;
    }

    ///@desc Clears all webhook data and resets to initial state.
    ///@return {Struct.DiscordWebhook} Returns self for method chaining.
    static Clear = function() {
        payload = {};
        for (var i = 0; i < array_length(files); i++) {
            if (buffer_exists(files[i].data)) {
                buffer_delete(files[i].data);
            }
        }
        files = [];
        message_id = undefined;
        request_id = undefined;
        processed = false;
        return self;
    }

    ///@desc Destroys the webhook object and cleans up all resources.
    ///@return {Undefined} No return value as object should be nullified after calling.
    static Destroy = function() {
        Clear();
        url = undefined;
    }
}